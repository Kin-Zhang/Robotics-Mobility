/*********************************************************/
/*** QUIZ 3.1.1 Review of kinematics (MATLAB)				   ***/
**********************************************************/

1. For all of this quiz, download and unzip the attached file.

	Using MATLAB, open the Q1 folder and edit "computeForwardKinematics.m" and compute forward kinematics for a single revolute link, replacing the trivial solution (x=0, y=0). Then run "singlelinkforward.m"To check that this is correct, drag the slider to θ1=2 what is the x coordinate of the end effector?

	Assume L1=1.

		En el fichero computeForwardKinematics.m introducir lo siguiente:
		theta = rads;
		L1 = 1;

		x = L1 * cos(theta);
		y = L1 * sin(theta);
		
		Solution:
		X = -0.4161 -> -0.42;

2. Using MATLAB, open the Q2 folder and edit "computeRRForwardKinematics.m" and compute forward kinematics for a revolute-revolute robot, replacing the trivial solution for both the elbow (joint connecting L1 and L2) and end effector (orange dot). To check that this is correct, run "rrForward.m" and drag the sliders to θ1=1 and θ2=0.75 what is the y coordinate of the end effector?

	Assume L1=1, and L2=1.

	En el fichero computeRrForwardKinematics.m introducir lo siguiente:

	l1 = 1; l2 = 1;

	joint_1_x = l1 * cos(rads1);
	joint_1_y = l1 * sin(rads1);

	effector_x = joint_1_x + l2 * cos(rads1 + rads2);
	effector_y = joint_1_y + l2 * sin(rads1 + rads2);

	elbow = [joint_1_x, joint_1_y];
	endeff =[effector_x, effector_y];

	Solution: 
	endeff =

    0.3621    1.8255 -> Y = 1.83
	Y = 0.8415 -> 0.84;

3. Using MATLAB, open the Q3 folder and edit "computeRRInverseKinematics.m" and compute inverse kinematics for a revolute-revolute robot. To check that this is correct, run "rrInverse.m" and drag the sliders to x=0 and y=1.5. What is the value of θ2, assuming that 0<_θ1<π/2 and 0<θ_2<2π?

	Assume L1=1, and L2=1.

	Note: There are technically two correct configurations, yet we are limiting the possible angles of θ1 in such a way that only one of the solutions is valid. 

		En el fichero computeRrForwardKinematics.m introducir lo siguiente:

		function [rads1,rads2] = computeRrInverseKinematics(X,Y)

		syms theta1 theta2 ;

		l1 = 1; l2 = 1;

		%% Effector
		theta_2_cos = (X^2 + Y^2 - l1^2 - l2^2) / (2 * l1 * l2);

		% Aplicando la igualdad cos² + sin² = 1
		theta_2_sin_pos = sqrt(1-((X^2 + Y^2 - l1^2 - l2^2) / (2 * l1 * l2))^2);
		theta_2_sin_neg = -(sqrt(1-((X^2 + Y^2 - l1^2 - l2^2) / (2 * l1 * l2))^2));

		theta_2_pos = atan2(theta_2_sin_pos, theta_2_cos)
		theta_2_neg = atan2(theta_2_sin_neg, theta_2_cos)

		%% Elbow
		theta_1_cos_pos = (X * (l1 + l2 * theta_2_cos) + Y * l2 * theta_2_sin_pos) / (X^2 + Y^2);
		theta_1_cos_neg = (X * (l1 + l2 * theta_2_cos) + Y * l2 * theta_2_sin_neg) / (X^2 + Y^2);

		theta_1_sin_pos = sqrt(1-(theta_1_cos_pos));
		theta_1_sin_neg = sqrt(1-(theta_1_cos_neg));

		theta_1_pos = atan2(theta_1_sin_pos, theta_1_cos_pos);
		theta_1_neg = atan2(theta_1_sin_pos, theta_1_cos_neg);

		%% Solution
		rads1=theta_1_pos;
		rads2=theta_2_pos;

		Solution:
		theta_2 = 1.441 -> 1.44;

4. Using MATLAB, open the Q4 folder and edit "computeMiniForwardKinematics.m" and compute the forward kinematics for a parallel robot. To check that this is correct, run "miniForwardNoToe.m" and drag the sliders to θ1=3.5 and θ2=1.5 what is the value of x?

	Assume the shorter link is of length 1 and the longer link is of length 2.

	function [endeff] = computeMiniForwardKinematics(rads1,rads2)

	l1 = 1; l2 = 2;

	alpha_world = (1/2) * (rads1 + rads2) + pi;
	beta_world = (rads1 - rads2);

	alpha_polar = alpha_world;
	r_polar = sqrt(l2^2 - (l1 * sin(beta_world)^2)) - l1 * cos(beta_world);

	x_world = r_polar * cos(alpha_polar);
	y_world = r_polar * sin(alpha_polar);

	endeff = [x_world, y_world];

	Solution: 
	X = 1.7605 -> 1.76
	--------------
	alpha = (1/2) * (rads1 + rads2) + pi;
	beta = (rads1 - rads2);

	Y = sqrt(1+1-2*1*1*cos(beta));
	Z = sqrt(1-(Y/2)^2);
	X = sqrt(4-(Y/2)^2);

	l = X-Z;

	x_world = l*cos(alpha);
	y_world = l*sin(alpha);

	endeff = [x_world, y_world];

	Solution: 
	X = 1.0207 -> 1.02

/*********************************************************/
/*** QUIZ 3.1.2 Introduction to dynamics and control   ***/
**********************************************************/
1. One possible simplification to the dynamics of the spring loaded inverted pendulum (SLIP) model is to neglect gravity altogether. Using your knowledge of Lagrangian mechanics, which of the below equations of motion are generated from this simplification?

	q = (r, theta)^T
	Kinetic Energy: T = (m/2) * ((derivate r)² + r²*(derivate theta)²)
	Potential Energy: V= (k/2) * (r - r_0)²

Note: The kinetic and potential energies are given using polar coordinates. The correct answer below is in simplest form and involves a cancellation. You can assume that the radial coordinate never goes to zero.

	m*derivate_seg_r - k(r_0 - r) - m*r*(derivate_theta)² = 0;
	r*derivate_seg_theta + 2*derivate_r*derivate_theta = 0;

	INCORRECT
	m*theta² + 2k(r0-r) + m*r*(derivate_r)² = 0;
	r*second_derivate_r - derivate_r*derivate_theta = 0;

2. Which of the following PD controllers -- used to directly give motor commands u -- is implemented correctly for the goal of having the motors to track the desired state? Let the desired state is given by the subscript "des", the proportional term be given by kp, and the derivative term be given by kd. 

	u = k_p(theta_des - theta) + k_d(derivate_theta_des - derivate_theta);

3. PD control allows the motors to add stiffness (via the P term) and damping (via the D term) in different directions. Often when controlling robotic legs it proves useful to have these directions align with some coordinate system at the foot. For example, you might want the motors to make the leg seem very stiff when the foot pushes against the ground in the vertical direction but not as much in the horizontal direction.

Assume a 2 degree of freedom leg actuated by 2 motors. Which of the following equations is a PD controller that gives motor commands to track a desired x and y foot position such that the leg stiffness and damping can be independently controlled in the x and y directions? Hint: it may be helpful to review the end of the kinematics section showing how forces at the end effector are mapped to motor torques.

Let J be the kinematic Jacobian, mapping motor velocities into toe velocities. Let k_px,k_py be the x and y proportional gains, and k_dx,k_dy be the x and y derivative gains.

	CORRECTO
	u = J^(T)[k_px(x_des - x) + k_dx(derivate_x_des - derivate_x); k_py(y_des - y) + k_dy(derivate_y_des - derivate_y)]

	INCORRECT
	u = J[k_px(x_des - x) + k_dx(derivate_x_des - derivate_x); k_py(y_des - y) + k_dy(derivate_y_des - derivate_y)]
	u = J^(-T)[k_px(x - x_des) + k_dx(derivate_x - derivate_x_des); k_py(y - y_des) + k_dy(derivate_y - derivate_y_des)]


/*********************************************************/
/*** QUIZ 3.2.1 Sprawled posture runners						   ***/
**********************************************************/


/*********************************************************/
/*** QUIZ 3.2.2 Quadrupeds													   ***/
**********************************************************/


/*********************************************************/
/*** QUIZ 3.2.3 Bipeds															   ***/
**********************************************************/


/*********************************************************/
/*** QUIZ 3.2.4 Simply strablized SLIP							   ***/
**********************************************************/